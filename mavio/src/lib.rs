//! # Mavio
//!
//! Minimalistic library for transport-agnostic [MAVLink](https://mavlink.io/en/) communication. It supports `no-std`
//! (and `no-alloc`) targets.
//!
//! <span style="font-size:24px">[ðŸ‡ºðŸ‡¦](https://mavka.gitlab.io/home/a_note_on_the_war_in_ukraine/)</span>
//! [![`repository`](https://img.shields.io/gitlab/pipeline-status/mavka/libs/mavio.svg?branch=main&label=repository)](https://gitlab.com/mavka/libs/mavio)
//! [![`crates.io`](https://img.shields.io/crates/v/mavio.svg)](https://crates.io/crates/mavio)
//! [![`docs.rs`](https://img.shields.io/docsrs/mavio.svg?label=docs.rs)](https://docs.rs/mavio/latest/mavio/)
//! [![`issues`](https://img.shields.io/gitlab/issues/open/mavka/libs/mavio.svg)](https://gitlab.com/mavka/libs/mavio/-/issues/)
//!
//! This library is a part of [Mavka](https://mavka.gitlab.io/home/) toolchain. It uses
//! [MAVSpec](https://gitlab.com/mavka/libs/mavspec) to generate MAVLink dialects.
//!
//! # Usage
//!
//! This library exposes [`Sender`] and [`Receiver`] to send and receive instances of MAVLink [`Frame`]. Frames contain
//! encoded message body in [`Frame::payload`] and additional fields (such as `sequence` or `system_id`) as required by
//! [MAVLink specification](https://mavlink.io/en/guide/serialization.html). Once frame is received, it can be decoded
//! into a specific `Message`. Frame decoding requires dialect specification which can be either generated manually by
//! using [MAVSpec](https://gitlab.com/mavka/libs/mavspec) or by enabling built-in [dialect features](#dialects).
//!
//! ### Receive
//!
//! Connect to TCP port and receive first 10 MAVLink frames, decode any received
//! [HEARTBEAT](https://mavlink.io/en/messages/common.html#HEARTBEAT) messages.
//!
//! ```no_run
//! # #[cfg(not(all(feature = "minimal", feature = "std")))]
//! # fn main() {}
//! # #[cfg(all(feature = "minimal", feature = "std"))]
//! # fn main() -> mavio::errors::Result<()> {
//! use std::net::TcpStream;
//! use mavio::{Frame, Receiver};
//! use mavio::dialects::minimal as dialect;
//! use dialect::Minimal;
//!
//! let mut receiver = Receiver::versionless(TcpStream::connect("0.0.0.0:5600")?);
//!
//! for i in 0..10 {
//!     let frame = receiver.recv_frame()?;
//!     
//!     if let Err(err) = frame.validate_checksum(dialect::spec()) {
//!         eprintln!("Invalid checksum: {err:?}");
//!         continue;
//!     }
//!
//!     if let Ok(Minimal::Heartbeat(msg)) = frame.decode() {
//!         println!(
//!             "HEARTBEAT #{}: mavlink_version={:#?}",
//!             frame.sequence(),
//!             msg.mavlink_version,
//!         );
//!     }
//! }
//!
//! # Ok(())
//! # }
//! ```
//!
//! ### Send
//!
//! Connect to TCP port and send 10 [HEARTBEAT](https://mavlink.io/en/messages/common.html#HEARTBEAT) messages using
//! `MAVLink 2` protocol.
//!
//! ```no_run
//! # #[cfg(not(all(feature = "minimal", feature = "std")))]
//! # fn main() {}
//! # #[cfg(all(feature = "minimal", feature = "std"))]
//! # fn main() -> mavio::errors::Result<()> {
//! use std::net::TcpStream;
//! use mavio::{Frame, Sender};
//! use mavio::protocol::V2;
//! use mavio::dialects::minimal as dialect;
//! use dialect::enums::{MavAutopilot, MavModeFlag, MavState, MavType};
//!
//! let mut sender = Sender::new(TcpStream::connect("0.0.0.0:5600")?);
//!
//! let mavlink_version = V2;
//! let system_id = 15;
//! let component_id = 42;
//!
//! for sequence in 0..10 {
//!     let message = dialect::messages::Heartbeat {
//!         type_: MavType::FixedWing,
//!         autopilot: MavAutopilot::Generic,
//!         base_mode: MavModeFlag::TEST_ENABLED
//!             & MavModeFlag::CUSTOM_MODE_ENABLED,
//!         custom_mode: 0,
//!         system_status: MavState::Active,
//!         mavlink_version: 3,
//!     };
//!     println!("MESSAGE #{}: {:#?}", sequence, message);
//!
//!     // Build a frame
//!     let frame = Frame::builder()
//!         .sequence(sequence)
//!         .system_id(system_id)
//!         .component_id(component_id)
//!         .version(mavlink_version)
//!         .message(&message)?
//!         .build();
//!
//!     sender.send_frame(&frame)?;
//!     println!("FRAME #{} sent: {:#?}", sequence, frame);
//! }
//!
//! # Ok(())
//! # }
//! ```
//!
//! # Features
//!
//! This library is a building block for more sophisticated tools. It includes absolute minimum of functionality
//! required for correct communication with everything that speaks MAVLink protocol:
//!
//! * It supports both `MAVLink 1` and `MAVLink 2` protocol versions.
//! * Provides intermediate MAVLink packets decoding with [`Frame`] that contain only header, checksum and signature
//!   being deserialized. Which means that client don't have to decode the entire message for routing and verification.
//! * Supports optional high-level message decoding by utilizing MAVLink abstractions generated by
//!   [MAVSpec](https://gitlab.com/mavka/libs/mavspec).
//! * Includes standard MAVLink dialects enabled by cargo features.
//! * Implements message verification via checksum.
//! * Includes tools for [message signing](https://mavlink.io/en/guide/message_signing.html).
//!
//! ## Extra features
//!
//! Most of the "extra" features are related to decoupling from MAVLink XML definitions parsing and code generation.
//! These tasks are performed by [MAVInspect](https://gitlab.com/mavka/libs/mavinspect) and
//! [MAVSpec](https://gitlab.com/mavka/libs/mavspec) respectively.
//!
//! * Supports custom dialects or may work with no dialect at all (for intermediate decoding).
//! * Includes support for custom payload decoders and encoders. Which means that clients are not bounded by
//!   abstractions generated by [MAVSpec](https://gitlab.com/mavka/libs/mavspec).
//! * Can read and write messages to anything that implements [`std::io::Read`](https://doc.rust-lang.org/std/io/trait.Read.html)
//!   and [`std::io::Write`](https://doc.rust-lang.org/std/io/trait.Write.html) traits.
//! * Compatible with `no_std` targets. For such cases the library provides simplified versions of `Read` and `Write`
//!   traits.
//! * Respects dialect inheritance. Messages defined in one dialect are not redefined upon inclusion into another
//!   dialect. This means that if you have a message `M` from dialect `A` being included by dialect `B`, it guaranteed
//!   that you can use Rust structs for message `M` with both of the dialects.
//!
//! ## Out of scope
//!
//! There are few *stateful* features required by MAVLink protocol this library intentionally does not implements and
//! leaves for the client:
//!
//! * Sending automatic [heartbeats](https://mavlink.io/en/services/heartbeat.html). This is required by most of the
//!   clients which would consider nodes without heartbeat updates as inactive or invalid.
//! * Message sequencing. This requires auto-incrementing packet sequence number upon each new message sent within a
//!   particular MAVLink network.  
//! * Stateful timestamp management for [message signing](https://mavlink.io/en/guide/message_signing.html) that ensures
//!   that two messages are not sent with the same timestamp.
//!
//! # Dialects
//!
//! Standard MAVLink dialect can be enabled by the corresponding feature flags.
//!
//! * [`minimal`]((https://mavlink.io/en/messages/minimal.html)) â€” minimal dialect required to expose your presence to
//!   other MAVLink devices.
//! * [`standard`](https://mavlink.io/en/messages/standard.html) â€” a superset of `minimal` dialect which expected to be
//!   used by almost all flight stack.
//! * [`common`](https://mavlink.io/en/messages/common.html) â€” minimum viable dialect with most of the features, a
//!   building block for other future-rich dialects.
//! * [`ardupilotmega`](https://mavlink.io/en/messages/common.html) â€” feature-full dialect used by
//!   [ArduPilot](http://ardupilot.org). In most cases this dialect is the go-to choice if you want to recognize almost
//!   all MAVLink messages used by existing flight stacks.
//! * [`all`](https://mavlink.io/en/messages/all.html) â€” meta-dialect which includes all other standard dialects
//!   including these which were created for testing purposes. It is guaranteed that namespaces of the dialects in `all`
//!   family do not collide.
//! * Other dialects from MAVLink XML [definitions](https://github.com/mavlink/mavlink/tree/master/message_definitions/v1.0):
//!   `asluav`, `avssuas`, `csairlink`, `cubepilot`, `development`, `icarous`, `matrixpilot`, `paparazzi`, `ualberta`,
//!   `uavionix`. These do not include `python_array_test` and `test` dialects which should be either generated manually
//!   or as a part of `all` meta-dialect.

#![warn(missing_docs)]
#![deny(rustdoc::broken_intra_doc_links)]
#![doc(
    html_logo_url = "https://gitlab.com/mavka/libs/mavio/-/raw/main/avatar.png?ref_type=heads",
    html_favicon_url = "https://gitlab.com/mavka/libs/mavio/-/raw/main/avatar.png?ref_type=heads"
)]
#![cfg_attr(not(feature = "std"), no_std)]

#[cfg(feature = "alloc")]
extern crate alloc;
extern crate core;

pub mod consts;
pub mod errors;
pub mod io;
pub mod prelude;
pub mod protocol;
pub mod utils;

#[cfg(feature = "tokio")]
#[doc(inline)]
pub use crate::io::{AsyncReceiver, AsyncSender};
#[doc(inline)]
pub use crate::io::{Receiver, Sender};
#[doc(inline)]
pub use errors::Result;
#[doc(inline)]
pub use protocol::Frame;

mod mavlink {
    include!(concat!(env!("OUT_DIR"), "/mavlink/mod.rs"));
}
pub use mavlink::dialects;
